package azurerm

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"fmt"

	"github.com/Azure/azure-sdk-for-go/services/hdinsight/mgmt/2015-03-01-preview/hdinsight"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/utils"
)

func resourceArmHDInsightClusters() *schema.Resource {
	return &schema.Resource{
		Create: resourceArmHDInsightClustersCreate,
		Read:   resourceArmHDInsightClustersRead,
		Update: resourceArmHDInsightClustersUpdate,
		Delete: resourceArmHDInsightClustersDelete,
		Schema: map[string]*schema.Schema{
			"blueprint": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"cluster_name": {
				Required: true,
				Type:     schema.TypeString,
			},
			"cluster_state": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"cluster_users_group_dns": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"cluster_version": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"component_version": {
				Optional: true,
				Type:     schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"configurations": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"connectivity_endpoints": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"location": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"name": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"port": {
							Optional: true,
							Type:     schema.TypeInt,
						},
						"protocol": {
							Optional: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"cores_used": {
				Optional: true,
				Type:     schema.TypeInt,
			},
			"created_date": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"directory_type": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"domain": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"domain_user_password": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"domain_username": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"errors": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"message": {
							Optional: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"kind": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"ldaps_urls": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"location": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"name": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"organizational_unit_dn": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"os_type": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"provisioning_state": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"resource_group_name": {
				Required: true,
				Type:     schema.TypeString,
			},
			"roles": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"data_disks_groups": {
							Optional: true,
							Type:     schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disk_size_gb": {
										Optional: true,
										Type:     schema.TypeInt,
									},
									"disks_per_node": {
										Optional: true,
										Type:     schema.TypeInt,
									},
									"storage_account_type": {
										Optional: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
						"id": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"min_instance_count": {
							Optional: true,
							Type:     schema.TypeInt,
						},
						"name": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"password": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"public_keys": {
							Optional: true,
							Type:     schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"certificate_data": {
										Optional: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
						"script_actions": {
							Optional: true,
							Type:     schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Required: true,
										Type:     schema.TypeString,
									},
									"parameters": {
										Required: true,
										Type:     schema.TypeString,
									},
									"uri": {
										Required: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
						"subnet": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"target_instance_count": {
							Optional: true,
							Type:     schema.TypeInt,
						},
						"username": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"vm_size": {
							Optional: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"storageaccounts": {
				Optional: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"container": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"is_default": {
							Optional: true,
							Type:     schema.TypeBool,
						},
						"key": {
							Optional: true,
							Type:     schema.TypeString,
						},
						"name": {
							Optional: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"tags": {
				Optional: true,
				Type:     schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"tier": {
				Optional: true,
				Type:     schema.TypeString,
			},
			"type": {
				Optional: true,
				Type:     schema.TypeString,
			},
		},
	}
}

func resourceArmHDInsightClustersCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	resourceGroupName := d.Get("resource_group_name").(string)
	clusterName := d.Get("cluster_name").(string)
	parameters := hdinsight.ClusterCreateParametersExtended{}
	parameters.Location = utils.String(d.Get("location").(string))
	tmpParamOfTags := make(map[string]*string)
	for tmpParamKeyOfTags, tmpParamItemOfTags := range d.Get("tags").(map[string]interface{}) {
		parametersTags := utils.String(tmpParamItemOfTags.(string))
		tmpParamOfTags[tmpParamKeyOfTags] = parametersTags
	}
	parameters.Tags = &tmpParamOfTags
	parameters.Properties = &hdinsight.ClusterCreateProperties{}
	parameters.Properties.ClusterVersion = utils.String(d.Get("cluster_version").(string))
	parameters.Properties.OsType = hdinsight.OSType(d.Get("os_type").(string))
	parameters.Properties.Tier = hdinsight.Tier(d.Get("tier").(string))
	parameters.Properties.ClusterDefinition = &hdinsight.ClusterDefinition{}
	parameters.Properties.ClusterDefinition.Blueprint = utils.String(d.Get("blueprint").(string))
	parameters.Properties.ClusterDefinition.Kind = utils.String(d.Get("kind").(string))
	tmpParamOfComponentVersion := make(map[string]*string)
	for tmpParamKeyOfComponentVersion, tmpParamItemOfComponentVersion := range d.Get("component_version").(map[string]interface{}) {
		parametersPropertiesClusterDefinitionComponentVersion := utils.String(tmpParamItemOfComponentVersion.(string))
		tmpParamOfComponentVersion[tmpParamKeyOfComponentVersion] = parametersPropertiesClusterDefinitionComponentVersion
	}
	parameters.Properties.ClusterDefinition.ComponentVersion = &tmpParamOfComponentVersion
	parameters.Properties.ClusterDefinition.Configurations = utils.String(d.Get("configurations").(string))
	parameters.Properties.SecurityProfile = &hdinsight.SecurityProfile{}
	parameters.Properties.SecurityProfile.DirectoryType = hdinsight.DirectoryType(d.Get("directory_type").(string))
	parameters.Properties.SecurityProfile.Domain = utils.String(d.Get("domain").(string))
	parameters.Properties.SecurityProfile.OrganizationalUnitDN = utils.String(d.Get("organizational_unit_dn").(string))
	tmpParamOfLdapsUrls := make([]string, 0)
	for _, tmpParamItemOfLdapsUrls := range d.Get("ldaps_urls").([]interface{}) {
		parametersPropertiesSecurityProfileLdapsUrls := utils.String(tmpParamItemOfLdapsUrls.(string))
		tmpParamOfLdapsUrls = append(tmpParamOfLdapsUrls, *parametersPropertiesSecurityProfileLdapsUrls)
	}
	parameters.Properties.SecurityProfile.LdapsUrls = &tmpParamOfLdapsUrls
	parameters.Properties.SecurityProfile.DomainUsername = utils.String(d.Get("domain_username").(string))
	parameters.Properties.SecurityProfile.DomainUserPassword = utils.String(d.Get("domain_user_password").(string))
	tmpParamOfClusterUsersGroupDns := make([]string, 0)
	for _, tmpParamItemOfClusterUsersGroupDns := range d.Get("cluster_users_group_dns").([]interface{}) {
		parametersPropertiesSecurityProfileClusterUsersGroupDNS := utils.String(tmpParamItemOfClusterUsersGroupDns.(string))
		tmpParamOfClusterUsersGroupDns = append(tmpParamOfClusterUsersGroupDns, *parametersPropertiesSecurityProfileClusterUsersGroupDNS)
	}
	parameters.Properties.SecurityProfile.ClusterUsersGroupDNS = &tmpParamOfClusterUsersGroupDns
	parameters.Properties.ComputeProfile = &hdinsight.ComputeProfile{}
	tmpParamOfRoles := make([]hdinsight.Role, 0)
	for _, tmpParamItemOfRoles := range d.Get("roles").([]interface{}) {
		tmpParamValueOfRoles := tmpParamItemOfRoles.(map[string]interface{})
		parametersPropertiesComputeProfileRoles := &hdinsight.Role{}
		parametersPropertiesComputeProfileRoles.Name = utils.String(tmpParamValueOfRoles["name"].(string))
		parametersPropertiesComputeProfileRoles.MinInstanceCount = utils.Int32(tmpParamValueOfRoles["min_instance_count"].(int32))
		parametersPropertiesComputeProfileRoles.TargetInstanceCount = utils.Int32(tmpParamValueOfRoles["target_instance_count"].(int32))
		parametersPropertiesComputeProfileRoles.HardwareProfile = &hdinsight.HardwareProfile{}
		parametersPropertiesComputeProfileRoles.HardwareProfile.VMSize = utils.String(tmpParamValueOfRoles["vm_size"].(string))
		parametersPropertiesComputeProfileRoles.OsProfile = &hdinsight.OsProfile{}
		parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile = &hdinsight.LinuxOperatingSystemProfile{}
		parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.Username = utils.String(tmpParamValueOfRoles["username"].(string))
		parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.Password = utils.String(tmpParamValueOfRoles["password"].(string))
		parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile = &hdinsight.SSHProfile{}
		tmpParamOfRolespublicKeys := make([]hdinsight.SSHPublicKey, 0)
		for _, tmpParamItemOfRolespublicKeys := range tmpParamValueOfRoles["public_keys"].([]interface{}) {
			tmpParamValueOfRolespublicKeys := tmpParamItemOfRolespublicKeys.(map[string]interface{})
			parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys := &hdinsight.SSHPublicKey{}
			parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys.CertificateData = utils.String(tmpParamValueOfRolespublicKeys["certificate_data"].(string))
			tmpParamOfRolespublicKeys = append(tmpParamOfRolespublicKeys, *parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys)
		}
		parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys = &tmpParamOfRolespublicKeys
		parametersPropertiesComputeProfileRoles.VirtualNetworkProfile = &hdinsight.VirtualNetworkProfile{}
		parametersPropertiesComputeProfileRoles.VirtualNetworkProfile.ID = utils.String(tmpParamValueOfRoles["id"].(string))
		parametersPropertiesComputeProfileRoles.VirtualNetworkProfile.Subnet = utils.String(tmpParamValueOfRoles["subnet"].(string))
		tmpParamOfRolesdataDisksGroups := make([]hdinsight.DataDisksGroups, 0)
		for _, tmpParamItemOfRolesdataDisksGroups := range tmpParamValueOfRoles["data_disks_groups"].([]interface{}) {
			tmpParamValueOfRolesdataDisksGroups := tmpParamItemOfRolesdataDisksGroups.(map[string]interface{})
			parametersPropertiesComputeProfileRolesDataDisksGroups := &hdinsight.DataDisksGroups{}
			parametersPropertiesComputeProfileRolesDataDisksGroups.DisksPerNode = utils.Int32(tmpParamValueOfRolesdataDisksGroups["disks_per_node"].(int32))
			parametersPropertiesComputeProfileRolesDataDisksGroups.StorageAccountType = utils.String(tmpParamValueOfRolesdataDisksGroups["storage_account_type"].(string))
			parametersPropertiesComputeProfileRolesDataDisksGroups.DiskSizeGB = utils.Int32(tmpParamValueOfRolesdataDisksGroups["disk_size_gb"].(int32))
			tmpParamOfRolesdataDisksGroups = append(tmpParamOfRolesdataDisksGroups, *parametersPropertiesComputeProfileRolesDataDisksGroups)
		}
		parametersPropertiesComputeProfileRoles.DataDisksGroups = &tmpParamOfRolesdataDisksGroups
		tmpParamOfRolesscriptActions := make([]hdinsight.ScriptAction, 0)
		for _, tmpParamItemOfRolesscriptActions := range tmpParamValueOfRoles["script_actions"].([]interface{}) {
			tmpParamValueOfRolesscriptActions := tmpParamItemOfRolesscriptActions.(map[string]interface{})
			parametersPropertiesComputeProfileRolesScriptActions := &hdinsight.ScriptAction{}
			parametersPropertiesComputeProfileRolesScriptActions.Name = utils.String(tmpParamValueOfRolesscriptActions["name"].(string))
			parametersPropertiesComputeProfileRolesScriptActions.URI = utils.String(tmpParamValueOfRolesscriptActions["uri"].(string))
			parametersPropertiesComputeProfileRolesScriptActions.Parameters = utils.String(tmpParamValueOfRolesscriptActions["parameters"].(string))
			tmpParamOfRolesscriptActions = append(tmpParamOfRolesscriptActions, *parametersPropertiesComputeProfileRolesScriptActions)
		}
		parametersPropertiesComputeProfileRoles.ScriptActions = &tmpParamOfRolesscriptActions
		tmpParamOfRoles = append(tmpParamOfRoles, *parametersPropertiesComputeProfileRoles)
	}
	parameters.Properties.ComputeProfile.Roles = &tmpParamOfRoles
	parameters.Properties.StorageProfile = &hdinsight.StorageProfile{}
	tmpParamOfStorageaccounts := make([]hdinsight.StorageAccount, 0)
	for _, tmpParamItemOfStorageaccounts := range d.Get("storageaccounts").([]interface{}) {
		tmpParamValueOfStorageaccounts := tmpParamItemOfStorageaccounts.(map[string]interface{})
		parametersPropertiesStorageProfileStorageaccounts := &hdinsight.StorageAccount{}
		parametersPropertiesStorageProfileStorageaccounts.Name = utils.String(tmpParamValueOfStorageaccounts["name"].(string))
		parametersPropertiesStorageProfileStorageaccounts.IsDefault = utils.Bool(tmpParamValueOfStorageaccounts["is_default"].(bool))
		parametersPropertiesStorageProfileStorageaccounts.Container = utils.String(tmpParamValueOfStorageaccounts["container"].(string))
		parametersPropertiesStorageProfileStorageaccounts.Key = utils.String(tmpParamValueOfStorageaccounts["key"].(string))
		tmpParamOfStorageaccounts = append(tmpParamOfStorageaccounts, *parametersPropertiesStorageProfileStorageaccounts)
	}
	parameters.Properties.StorageProfile.Storageaccounts = &tmpParamOfStorageaccounts

	future, err := client.Create(ctx, resourceGroupName, clusterName, parameters)
	if err != nil {
		return fmt.Errorf("Error creating HD Insight Clusters: %+v", err)
	}
	err = future.WaitForCompletion(ctx, client.Client)
	if err != nil {
		return fmt.Errorf("Error creating HD Insight Clusters: %+v", err)
	}
	response, err := future.Result(client)
	if err != nil {
		return fmt.Errorf("Error creating HD Insight Clusters: %+v", err)
	}

	d.Set("name", *response.Name)
	d.Set("type", *response.Type)
	d.Set("location", *response.Location)
	tmpRespOfTags := make(map[string]interface{})
	for tmpRespKeyOfTags, tmpRespItemOfTags := range *response.Tags {
		tmpRespValueOfTags := *tmpRespItemOfTags
		tmpRespOfTags[tmpRespKeyOfTags] = tmpRespValueOfTags
	}
	d.Set("tags", tmpRespOfTags)
	d.Set("cluster_version", *response.Properties.ClusterVersion)
	d.Set("os_type", response.Properties.OsType)
	d.Set("tier", response.Properties.Tier)
	d.Set("blueprint", *response.Properties.ClusterDefinition.Blueprint)
	d.Set("kind", *response.Properties.ClusterDefinition.Kind)
	tmpRespOfComponentVersion := make(map[string]interface{})
	for tmpRespKeyOfComponentVersion, tmpRespItemOfComponentVersion := range *response.Properties.ClusterDefinition.ComponentVersion {
		tmpRespValueOfComponentVersion := *tmpRespItemOfComponentVersion
		tmpRespOfComponentVersion[tmpRespKeyOfComponentVersion] = tmpRespValueOfComponentVersion
	}
	d.Set("component_version", tmpRespOfComponentVersion)
	d.Set("configurations", *response.Properties.ClusterDefinition.Configurations)
	d.Set("directory_type", response.Properties.SecurityProfile.DirectoryType)
	d.Set("domain", *response.Properties.SecurityProfile.Domain)
	d.Set("organizational_unit_dn", *response.Properties.SecurityProfile.OrganizationalUnitDN)
	tmpRespOfLdapsUrls := make([]interface{}, 0)
	for _, tmpRespItemOfLdapsUrls := range *response.Properties.SecurityProfile.LdapsUrls {
		tmpRespValueOfLdapsUrls := tmpRespItemOfLdapsUrls
		tmpRespOfLdapsUrls = append(tmpRespOfLdapsUrls, tmpRespValueOfLdapsUrls)
	}
	d.Set("ldaps_urls", tmpRespOfLdapsUrls)
	d.Set("domain_username", *response.Properties.SecurityProfile.DomainUsername)
	d.Set("domain_user_password", *response.Properties.SecurityProfile.DomainUserPassword)
	tmpRespOfClusterUsersGroupDns := make([]interface{}, 0)
	for _, tmpRespItemOfClusterUsersGroupDns := range *response.Properties.SecurityProfile.ClusterUsersGroupDNS {
		tmpRespValueOfClusterUsersGroupDns := tmpRespItemOfClusterUsersGroupDns
		tmpRespOfClusterUsersGroupDns = append(tmpRespOfClusterUsersGroupDns, tmpRespValueOfClusterUsersGroupDns)
	}
	d.Set("cluster_users_group_dns", tmpRespOfClusterUsersGroupDns)
	tmpRespOfRoles := make([]interface{}, 0)
	for _, tmpRespItemOfRoles := range *response.Properties.ComputeProfile.Roles {
		tmpRespValueOfRoles := make(map[string]interface{})
		tmpRespValueOfRoles["name"] = *tmpRespItemOfRoles.Name
		tmpRespValueOfRoles["min_instance_count"] = *tmpRespItemOfRoles.MinInstanceCount
		tmpRespValueOfRoles["target_instance_count"] = *tmpRespItemOfRoles.TargetInstanceCount
		tmpRespValueOfRoles["vm_size"] = *tmpRespItemOfRoles.HardwareProfile.VMSize
		tmpRespValueOfRoles["username"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username
		tmpRespValueOfRoles["password"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password
		tmpRespOfRolespublicKeys := make([]interface{}, 0)
		for _, tmpRespItemOfRolespublicKeys := range *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys {
			tmpRespValueOfRolespublicKeys := make(map[string]interface{})
			tmpRespValueOfRolespublicKeys["certificate_data"] = *tmpRespItemOfRolespublicKeys.CertificateData
			tmpRespOfRolespublicKeys = append(tmpRespOfRolespublicKeys, tmpRespValueOfRolespublicKeys)
		}
		tmpRespValueOfRoles["public_keys"] = tmpRespOfRolespublicKeys
		tmpRespValueOfRoles["id"] = *tmpRespItemOfRoles.VirtualNetworkProfile.ID
		tmpRespValueOfRoles["subnet"] = *tmpRespItemOfRoles.VirtualNetworkProfile.Subnet
		tmpRespOfRolesdataDisksGroups := make([]interface{}, 0)
		for _, tmpRespItemOfRolesdataDisksGroups := range *tmpRespItemOfRoles.DataDisksGroups {
			tmpRespValueOfRolesdataDisksGroups := make(map[string]interface{})
			tmpRespValueOfRolesdataDisksGroups["disks_per_node"] = *tmpRespItemOfRolesdataDisksGroups.DisksPerNode
			tmpRespValueOfRolesdataDisksGroups["storage_account_type"] = *tmpRespItemOfRolesdataDisksGroups.StorageAccountType
			tmpRespValueOfRolesdataDisksGroups["disk_size_gb"] = *tmpRespItemOfRolesdataDisksGroups.DiskSizeGB
			tmpRespOfRolesdataDisksGroups = append(tmpRespOfRolesdataDisksGroups, tmpRespValueOfRolesdataDisksGroups)
		}
		tmpRespValueOfRoles["data_disks_groups"] = tmpRespOfRolesdataDisksGroups
		tmpRespOfRolesscriptActions := make([]interface{}, 0)
		for _, tmpRespItemOfRolesscriptActions := range *tmpRespItemOfRoles.ScriptActions {
			tmpRespValueOfRolesscriptActions := make(map[string]interface{})
			tmpRespValueOfRolesscriptActions["name"] = *tmpRespItemOfRolesscriptActions.Name
			tmpRespValueOfRolesscriptActions["uri"] = *tmpRespItemOfRolesscriptActions.URI
			tmpRespValueOfRolesscriptActions["parameters"] = *tmpRespItemOfRolesscriptActions.Parameters
			tmpRespOfRolesscriptActions = append(tmpRespOfRolesscriptActions, tmpRespValueOfRolesscriptActions)
		}
		tmpRespValueOfRoles["script_actions"] = tmpRespOfRolesscriptActions
		tmpRespOfRoles = append(tmpRespOfRoles, tmpRespValueOfRoles)
	}
	d.Set("roles", tmpRespOfRoles)
	d.Set("provisioning_state", response.Properties.ProvisioningState)
	d.Set("created_date", *response.Properties.CreatedDate)
	d.Set("cluster_state", *response.Properties.ClusterState)
	d.Set("cores_used", *response.Properties.QuotaInfo.CoresUsed)
	tmpRespOfErrors := make([]interface{}, 0)
	for _, tmpRespItemOfErrors := range *response.Properties.Errors {
		tmpRespValueOfErrors := make(map[string]interface{})
		tmpRespValueOfErrors["code"] = *tmpRespItemOfErrors.Code
		tmpRespValueOfErrors["message"] = *tmpRespItemOfErrors.Message
		tmpRespOfErrors = append(tmpRespOfErrors, tmpRespValueOfErrors)
	}
	d.Set("errors", tmpRespOfErrors)
	tmpRespOfConnectivityEndpoints := make([]interface{}, 0)
	for _, tmpRespItemOfConnectivityEndpoints := range *response.Properties.ConnectivityEndpoints {
		tmpRespValueOfConnectivityEndpoints := make(map[string]interface{})
		tmpRespValueOfConnectivityEndpoints["name"] = *tmpRespItemOfConnectivityEndpoints.Name
		tmpRespValueOfConnectivityEndpoints["protocol"] = *tmpRespItemOfConnectivityEndpoints.Protocol
		tmpRespValueOfConnectivityEndpoints["location"] = *tmpRespItemOfConnectivityEndpoints.Location
		tmpRespValueOfConnectivityEndpoints["port"] = *tmpRespItemOfConnectivityEndpoints.Port
		tmpRespOfConnectivityEndpoints = append(tmpRespOfConnectivityEndpoints, tmpRespValueOfConnectivityEndpoints)
	}
	d.Set("connectivity_endpoints", tmpRespOfConnectivityEndpoints)

	return nil
}

func resourceArmHDInsightClustersRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	return nil
}

func resourceArmHDInsightClustersUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	return nil
}

func resourceArmHDInsightClustersDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	return nil
}
