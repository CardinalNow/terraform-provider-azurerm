package azurerm

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"fmt"

	"github.com/Azure/azure-sdk-for-go/services/hdinsight/mgmt/2015-03-01-preview/hdinsight"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/helper/validation"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/utils"
)

func resourceArmHDInsightClusters() *schema.Resource {
	return &schema.Resource{
		Create: resourceArmHDInsightClustersCreate,
		Read:   resourceArmHDInsightClustersRead,
		Update: resourceArmHDInsightClustersUpdate,
		Delete: resourceArmHDInsightClustersDelete,
		Schema: map[string]*schema.Schema{
			"blueprint": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeString,
			},
			"cluster_state": {
				Computed: true,
				Type:     schema.TypeString,
			},
			"cluster_version": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeString,
			},
			"component_version": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"configurations": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeMap,
					Elem: &schema.Schema{
						Type: schema.TypeString,
					},
				},
			},
			"connectivity_endpoints": {
				Computed: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"location": {
							Computed: true,
							Type:     schema.TypeString,
						},
						"name": {
							Computed: true,
							Type:     schema.TypeString,
						},
						"port": {
							Computed: true,
							Type:     schema.TypeInt,
						},
						"protocol": {
							Computed: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"cores_used": {
				Computed: true,
				Type:     schema.TypeInt,
			},
			"created_date": {
				Computed: true,
				Type:     schema.TypeString,
			},
			"errors": {
				Computed: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Computed: true,
							Type:     schema.TypeString,
						},
						"message": {
							Computed: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"kind": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeString,
				ValidateFunc: validation.StringInSlice([]string{
					"hadoop",
					"hbase",
					"storm",
					"spark",
				}, true),
			},
			"location": locationSchema(),
			"name": {
				Required: true,
				ForceNew: true,
				Type:     schema.TypeString,
			},
			"os_type": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeString,
				ValidateFunc: validation.StringInSlice([]string{
					"Linux",
					"Windows",
				}, true),
			},
			"provisioning_state": {
				Computed: true,
				Type:     schema.TypeString,
			},
			"resource_group_name": resourceGroupNameSchema(),
			"roles": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"data_disks_groups": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disk_size_gb": {
										Optional:     true,
										ForceNew:     true,
										Type:         schema.TypeInt,
										ValidateFunc: validateDiskSizeGB,
									},
									"disks_per_node": {
										Optional:     true,
										ForceNew:     true,
										Type:         schema.TypeInt,
										ValidateFunc: validation.IntBetween(0, 10),
									},
									"storage_account_type": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeString,
										ValidateFunc: validation.StringInSlice([]string{
											"Standard_LRS",
											"Standard_GRS",
											"Standard_RAGRS",
											"Standard_ZRS",
										}, true),
									},
								},
							},
						},
						"linux_os_profile": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"password": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
									"ssh_keys": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeList,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"key_data": {
													Optional: true,
													ForceNew: true,
													Type:     schema.TypeString,
												},
											},
										},
									},
									"username": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
						"min_instance_count": {
							Optional:     true,
							ForceNew:     true,
							Type:         schema.TypeInt,
							ValidateFunc: validation.IntBetween(1, 32),
						},
						"name": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"script_actions": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Required: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
									"parameters": {
										Required: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
									"uri": {
										Required: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
						"target_instance_count": {
							Optional:     true,
							ForceNew:     true,
							Type:         schema.TypeInt,
							ValidateFunc: validation.IntBetween(1, 32),
						},
						"vm_size": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"vnet_profile": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
									"subnet": {
										Optional: true,
										ForceNew: true,
										Type:     schema.TypeString,
									},
								},
							},
						},
					},
				},
			},
			"security_profile": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeList,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cluster_users_group_dns": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"directory_type": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"domain": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"domain_user_password": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"domain_username": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"ldaps_urls": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeList,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"organizational_unit_dn": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"storageaccounts": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"container": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"is_default": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeBool,
						},
						"key": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
						"name": {
							Optional: true,
							ForceNew: true,
							Type:     schema.TypeString,
						},
					},
				},
			},
			"tags": tagsSchema(),
			"tier": {
				Optional: true,
				ForceNew: true,
				Type:     schema.TypeString,
				ValidateFunc: validation.StringInSlice([]string{
					"standard",
					"premium",
				}, false),
			},
		},
	}
}

func resourceArmHDInsightClustersCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	resourceGroupName := d.Get("resource_group_name").(string)
	clusterName := d.Get("name").(string)
	parameters := hdinsight.ClusterCreateParametersExtended{}
	if paramValue, paramExists := d.GetOk("location"); paramExists {
		parameters.Location = utils.String(paramValue.(string))
	}
	tags := d.Get("tags").(map[string]interface{})
	tmpParamOfTags := expandTags(tags)
	parameters.Tags = tmpParamOfTags
	parameters.Properties = &hdinsight.ClusterCreateProperties{}
	if paramValue, paramExists := d.GetOk("cluster_version"); paramExists {
		parameters.Properties.ClusterVersion = utils.String(paramValue.(string))
	}
	if paramValue, paramExists := d.GetOk("os_type"); paramExists {
		parameters.Properties.OsType = hdinsight.OSType(paramValue.(string))
	}
	if paramValue, paramExists := d.GetOk("tier"); paramExists {
		parameters.Properties.Tier = hdinsight.Tier(paramValue.(string))
	}
	parameters.Properties.ClusterDefinition = &hdinsight.ClusterDefinition{}
	if paramValue, paramExists := d.GetOk("blueprint"); paramExists {
		parameters.Properties.ClusterDefinition.Blueprint = utils.String(paramValue.(string))
	}
	if paramValue, paramExists := d.GetOk("kind"); paramExists {
		parameters.Properties.ClusterDefinition.Kind = utils.String(paramValue.(string))
	}
	if paramValue, paramExists := d.GetOk("component_version"); paramExists {
		tmpParamOfComponentVersion := make(map[string]*string)
		for tmpParamKeyOfComponentVersion, tmpParamItemOfComponentVersion := range paramValue.(map[string]interface{}) {
			parametersPropertiesClusterDefinitionComponentVersion := utils.String(tmpParamItemOfComponentVersion.(string))
			tmpParamOfComponentVersion[tmpParamKeyOfComponentVersion] = parametersPropertiesClusterDefinitionComponentVersion
		}
		parameters.Properties.ClusterDefinition.ComponentVersion = &tmpParamOfComponentVersion
	}
	if paramValue, paramExists := d.GetOk("configurations"); paramExists {
		tmpParamOfConfigurations := make(map[string]interface{})
		for tmpParamKeyOfConfigurations, tmpParamItemOfConfigurations := range paramValue.(map[string]interface{}) {
			tmpParamValueOfConfigurations := tmpParamItemOfConfigurations.(map[string]interface{})
			tmpParamOfConfigurations1 := make(map[string]*string)
			for tmpParamKeyOfConfigurations1, tmpParamItemOfConfigurations1 := range tmpParamValueOfConfigurations {
				parametersPropertiesClusterDefinitionConfigurations := utils.String(tmpParamItemOfConfigurations1.(string))
				tmpParamOfConfigurations1[tmpParamKeyOfConfigurations1] = parametersPropertiesClusterDefinitionConfigurations
			}
			parametersPropertiesClusterDefinitionConfigurations := &tmpParamOfConfigurations1
			tmpParamOfConfigurations[tmpParamKeyOfConfigurations] = parametersPropertiesClusterDefinitionConfigurations
		}
		parameters.Properties.ClusterDefinition.Configurations = &tmpParamOfConfigurations
	}
	parameters.Properties.SecurityProfile = &hdinsight.SecurityProfile{}
	if paramValue, paramExists := d.GetOk("security_profile"); paramExists {
		tmpParamOfSecurityProfile := paramValue.(map[string]interface{})
		if paramValue, paramExists := tmpParamOfSecurityProfile["directory_type"]; paramExists {
			parameters.Properties.SecurityProfile.DirectoryType = hdinsight.DirectoryType(paramValue.(string))
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["domain"]; paramExists {
			parameters.Properties.SecurityProfile.Domain = utils.String(paramValue.(string))
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["organizational_unit_dn"]; paramExists {
			parameters.Properties.SecurityProfile.OrganizationalUnitDN = utils.String(paramValue.(string))
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["ldaps_urls"]; paramExists {
			tmpParamOfSecurityProfileldapsUrls := make([]string, 0)
			for _, tmpParamItemOfSecurityProfileldapsUrls := range paramValue.([]interface{}) {
				parametersPropertiesSecurityProfileLdapsUrls := utils.String(tmpParamItemOfSecurityProfileldapsUrls.(string))
				tmpParamOfSecurityProfileldapsUrls = append(tmpParamOfSecurityProfileldapsUrls, *parametersPropertiesSecurityProfileLdapsUrls)
			}
			parameters.Properties.SecurityProfile.LdapsUrls = &tmpParamOfSecurityProfileldapsUrls
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["domain_username"]; paramExists {
			parameters.Properties.SecurityProfile.DomainUsername = utils.String(paramValue.(string))
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["domain_user_password"]; paramExists {
			parameters.Properties.SecurityProfile.DomainUserPassword = utils.String(paramValue.(string))
		}
		if paramValue, paramExists := tmpParamOfSecurityProfile["cluster_users_group_dns"]; paramExists {
			tmpParamOfSecurityProfileclusterUsersGroupDns := make([]string, 0)
			for _, tmpParamItemOfSecurityProfileclusterUsersGroupDns := range paramValue.([]interface{}) {
				parametersPropertiesSecurityProfileClusterUsersGroupDNS := utils.String(tmpParamItemOfSecurityProfileclusterUsersGroupDns.(string))
				tmpParamOfSecurityProfileclusterUsersGroupDns = append(tmpParamOfSecurityProfileclusterUsersGroupDns, *parametersPropertiesSecurityProfileClusterUsersGroupDNS)
			}
			parameters.Properties.SecurityProfile.ClusterUsersGroupDNS = &tmpParamOfSecurityProfileclusterUsersGroupDns
		}
	}
	parameters.Properties.ComputeProfile = &hdinsight.ComputeProfile{}
	if paramValue, paramExists := d.GetOk("roles"); paramExists {
		tmpParamOfRoles := make([]hdinsight.Role, 0)
		for _, tmpParamItemOfRoles := range paramValue.([]interface{}) {
			tmpParamValueOfRoles := tmpParamItemOfRoles.(map[string]interface{})
			parametersPropertiesComputeProfileRoles := &hdinsight.Role{}
			if paramValue, paramExists := tmpParamValueOfRoles["name"]; paramExists {
				parametersPropertiesComputeProfileRoles.Name = utils.String(paramValue.(string))
			}
			if paramValue, paramExists := tmpParamValueOfRoles["min_instance_count"]; paramExists {
				parametersPropertiesComputeProfileRoles.MinInstanceCount = utils.Int32(paramValue.(int32))
			}
			if paramValue, paramExists := tmpParamValueOfRoles["target_instance_count"]; paramExists {
				parametersPropertiesComputeProfileRoles.TargetInstanceCount = utils.Int32(paramValue.(int32))
			}
			parametersPropertiesComputeProfileRoles.HardwareProfile = &hdinsight.HardwareProfile{}
			if paramValue, paramExists := tmpParamValueOfRoles["vm_size"]; paramExists {
				parametersPropertiesComputeProfileRoles.HardwareProfile.VMSize = utils.String(paramValue.(string))
			}
			parametersPropertiesComputeProfileRoles.OsProfile = &hdinsight.OsProfile{}
			parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile = &hdinsight.LinuxOperatingSystemProfile{}
			if paramValue, paramExists := tmpParamValueOfRoles["linux_os_profile"]; paramExists {
				tmpParamOfRoleslinuxOsProfile := paramValue.(map[string]interface{})
				if paramValue, paramExists := tmpParamOfRoleslinuxOsProfile["username"]; paramExists {
					parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.Username = utils.String(paramValue.(string))
				}
				if paramValue, paramExists := tmpParamOfRoleslinuxOsProfile["password"]; paramExists {
					parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.Password = utils.String(paramValue.(string))
				}
				parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile = &hdinsight.SSHProfile{}
				if paramValue, paramExists := tmpParamOfRoleslinuxOsProfile["ssh_keys"]; paramExists {
					tmpParamOfRoleslinuxOsProfilesshKeys := make([]hdinsight.SSHPublicKey, 0)
					for _, tmpParamItemOfRoleslinuxOsProfilesshKeys := range paramValue.([]interface{}) {
						tmpParamValueOfRoleslinuxOsProfilesshKeys := tmpParamItemOfRoleslinuxOsProfilesshKeys.(map[string]interface{})
						parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys := &hdinsight.SSHPublicKey{}
						if paramValue, paramExists := tmpParamValueOfRoleslinuxOsProfilesshKeys["key_data"]; paramExists {
							parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys.CertificateData = utils.String(paramValue.(string))
						}
						tmpParamOfRoleslinuxOsProfilesshKeys = append(tmpParamOfRoleslinuxOsProfilesshKeys, *parametersPropertiesComputeProfileRolesOsProfileLinuxOperatingSystemProfileSSHProfilePublicKeys)
					}
					parametersPropertiesComputeProfileRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys = &tmpParamOfRoleslinuxOsProfilesshKeys
				}
			}
			parametersPropertiesComputeProfileRoles.VirtualNetworkProfile = &hdinsight.VirtualNetworkProfile{}
			if paramValue, paramExists := tmpParamValueOfRoles["vnet_profile"]; paramExists {
				tmpParamOfRolesvnetProfile := paramValue.(map[string]interface{})
				if paramValue, paramExists := tmpParamOfRolesvnetProfile["id"]; paramExists {
					parametersPropertiesComputeProfileRoles.VirtualNetworkProfile.ID = utils.String(paramValue.(string))
				}
				if paramValue, paramExists := tmpParamOfRolesvnetProfile["subnet"]; paramExists {
					parametersPropertiesComputeProfileRoles.VirtualNetworkProfile.Subnet = utils.String(paramValue.(string))
				}
			}
			if paramValue, paramExists := tmpParamValueOfRoles["data_disks_groups"]; paramExists {
				tmpParamOfRolesdataDisksGroups := make([]hdinsight.DataDisksGroups, 0)
				for _, tmpParamItemOfRolesdataDisksGroups := range paramValue.([]interface{}) {
					tmpParamValueOfRolesdataDisksGroups := tmpParamItemOfRolesdataDisksGroups.(map[string]interface{})
					parametersPropertiesComputeProfileRolesDataDisksGroups := &hdinsight.DataDisksGroups{}
					if paramValue, paramExists := tmpParamValueOfRolesdataDisksGroups["disks_per_node"]; paramExists {
						parametersPropertiesComputeProfileRolesDataDisksGroups.DisksPerNode = utils.Int32(paramValue.(int32))
					}
					if paramValue, paramExists := tmpParamValueOfRolesdataDisksGroups["storage_account_type"]; paramExists {
						parametersPropertiesComputeProfileRolesDataDisksGroups.StorageAccountType = utils.String(paramValue.(string))
					}
					if paramValue, paramExists := tmpParamValueOfRolesdataDisksGroups["disk_size_gb"]; paramExists {
						parametersPropertiesComputeProfileRolesDataDisksGroups.DiskSizeGB = utils.Int32(paramValue.(int32))
					}
					tmpParamOfRolesdataDisksGroups = append(tmpParamOfRolesdataDisksGroups, *parametersPropertiesComputeProfileRolesDataDisksGroups)
				}
				parametersPropertiesComputeProfileRoles.DataDisksGroups = &tmpParamOfRolesdataDisksGroups
			}
			if paramValue, paramExists := tmpParamValueOfRoles["script_actions"]; paramExists {
				tmpParamOfRolesscriptActions := make([]hdinsight.ScriptAction, 0)
				for _, tmpParamItemOfRolesscriptActions := range paramValue.([]interface{}) {
					tmpParamValueOfRolesscriptActions := tmpParamItemOfRolesscriptActions.(map[string]interface{})
					parametersPropertiesComputeProfileRolesScriptActions := &hdinsight.ScriptAction{}
					parametersPropertiesComputeProfileRolesScriptActions.Name = utils.String(tmpParamValueOfRolesscriptActions["name"].(string))
					parametersPropertiesComputeProfileRolesScriptActions.URI = utils.String(tmpParamValueOfRolesscriptActions["uri"].(string))
					parametersPropertiesComputeProfileRolesScriptActions.Parameters = utils.String(tmpParamValueOfRolesscriptActions["parameters"].(string))
					tmpParamOfRolesscriptActions = append(tmpParamOfRolesscriptActions, *parametersPropertiesComputeProfileRolesScriptActions)
				}
				parametersPropertiesComputeProfileRoles.ScriptActions = &tmpParamOfRolesscriptActions
			}
			tmpParamOfRoles = append(tmpParamOfRoles, *parametersPropertiesComputeProfileRoles)
		}
		parameters.Properties.ComputeProfile.Roles = &tmpParamOfRoles
	}
	parameters.Properties.StorageProfile = &hdinsight.StorageProfile{}
	if paramValue, paramExists := d.GetOk("storageaccounts"); paramExists {
		tmpParamOfStorageaccounts := make([]hdinsight.StorageAccount, 0)
		for _, tmpParamItemOfStorageaccounts := range paramValue.([]interface{}) {
			tmpParamValueOfStorageaccounts := tmpParamItemOfStorageaccounts.(map[string]interface{})
			parametersPropertiesStorageProfileStorageaccounts := &hdinsight.StorageAccount{}
			if paramValue, paramExists := tmpParamValueOfStorageaccounts["name"]; paramExists {
				parametersPropertiesStorageProfileStorageaccounts.Name = utils.String(paramValue.(string))
			}
			if paramValue, paramExists := tmpParamValueOfStorageaccounts["is_default"]; paramExists {
				parametersPropertiesStorageProfileStorageaccounts.IsDefault = utils.Bool(paramValue.(bool))
			}
			if paramValue, paramExists := tmpParamValueOfStorageaccounts["container"]; paramExists {
				parametersPropertiesStorageProfileStorageaccounts.Container = utils.String(paramValue.(string))
			}
			if paramValue, paramExists := tmpParamValueOfStorageaccounts["key"]; paramExists {
				parametersPropertiesStorageProfileStorageaccounts.Key = utils.String(paramValue.(string))
			}
			tmpParamOfStorageaccounts = append(tmpParamOfStorageaccounts, *parametersPropertiesStorageProfileStorageaccounts)
		}
		parameters.Properties.StorageProfile.Storageaccounts = &tmpParamOfStorageaccounts
	}

	future, err := client.Create(ctx, resourceGroupName, clusterName, parameters)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters creation error: %+v", err)
	}
	err = future.WaitForCompletion(ctx, client.Client)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters creation future wait for completion error: %+v", err)
	}
	response, err := future.Result(client)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters creation future result error: %+v", err)
	}

	d.SetId(*response.ID)

	if response.Name != nil {
		d.Set("name", *response.Name)
	}
	if response.Location != nil {
		d.Set("location", *response.Location)
	}
	flattenAndSetTags(d, response.Tags)
	if response.Properties != nil {
		if response.Properties.ClusterVersion != nil {
			d.Set("cluster_version", *response.Properties.ClusterVersion)
		}
		d.Set("os_type", response.Properties.OsType)
		d.Set("tier", response.Properties.Tier)
		if response.Properties.ClusterDefinition.Blueprint != nil {
			d.Set("blueprint", *response.Properties.ClusterDefinition.Blueprint)
		}
		if response.Properties.ClusterDefinition.Kind != nil {
			d.Set("kind", *response.Properties.ClusterDefinition.Kind)
		}
		if response.Properties.ClusterDefinition.ComponentVersion != nil {
			tmpRespOfComponentVersion := make(map[string]interface{})
			for tmpRespKeyOfComponentVersion, tmpRespItemOfComponentVersion := range *response.Properties.ClusterDefinition.ComponentVersion {
				tmpRespValueOfComponentVersion := *tmpRespItemOfComponentVersion
				tmpRespOfComponentVersion[tmpRespKeyOfComponentVersion] = tmpRespValueOfComponentVersion
			}
			d.Set("component_version", tmpRespOfComponentVersion)
		}
		if response.Properties.ClusterDefinition.Configurations != nil {
			tmpRespOfConfigurations := make(map[string]interface{})
			for tmpRespKeyOfConfigurations, tmpRespItemOfConfigurations := range *response.Properties.ClusterDefinition.Configurations {
				tmpRespOfConfigurations1 := make(map[string]interface{})
				for tmpRespKeyOfConfigurations1, tmpRespItemOfConfigurations1 := range *tmpRespItemOfConfigurations.(*map[string]*string) {
					tmpRespValueOfConfigurations1 := *tmpRespItemOfConfigurations1
					tmpRespOfConfigurations1[tmpRespKeyOfConfigurations1] = tmpRespValueOfConfigurations1
				}
				tmpRespOfConfigurations[tmpRespKeyOfConfigurations] = tmpRespOfConfigurations1
			}
			d.Set("configurations", tmpRespOfConfigurations)
		}
		if response.Properties.SecurityProfile != nil {
			tmpRespOfSecurityProfile := make(map[string]interface{})
			tmpRespOfSecurityProfile["directory_type"] = response.Properties.SecurityProfile.DirectoryType
			if response.Properties.SecurityProfile.Domain != nil {
				tmpRespOfSecurityProfile["domain"] = *response.Properties.SecurityProfile.Domain
			}
			if response.Properties.SecurityProfile.OrganizationalUnitDN != nil {
				tmpRespOfSecurityProfile["organizational_unit_dn"] = *response.Properties.SecurityProfile.OrganizationalUnitDN
			}
			if response.Properties.SecurityProfile.LdapsUrls != nil && len(*response.Properties.SecurityProfile.LdapsUrls) > 0 {
				tmpRespOfSecurityProfileldapsUrls := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileldapsUrls := range *response.Properties.SecurityProfile.LdapsUrls {
					tmpRespValueOfSecurityProfileldapsUrls := tmpRespItemOfSecurityProfileldapsUrls
					tmpRespOfSecurityProfileldapsUrls = append(tmpRespOfSecurityProfileldapsUrls, tmpRespValueOfSecurityProfileldapsUrls)
				}
				tmpRespOfSecurityProfile["ldaps_urls"] = tmpRespOfSecurityProfileldapsUrls
			}
			if response.Properties.SecurityProfile.DomainUsername != nil {
				tmpRespOfSecurityProfile["domain_username"] = *response.Properties.SecurityProfile.DomainUsername
			}
			if response.Properties.SecurityProfile.DomainUserPassword != nil {
				tmpRespOfSecurityProfile["domain_user_password"] = *response.Properties.SecurityProfile.DomainUserPassword
			}
			if response.Properties.SecurityProfile.ClusterUsersGroupDNS != nil && len(*response.Properties.SecurityProfile.ClusterUsersGroupDNS) > 0 {
				tmpRespOfSecurityProfileclusterUsersGroupDns := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileclusterUsersGroupDns := range *response.Properties.SecurityProfile.ClusterUsersGroupDNS {
					tmpRespValueOfSecurityProfileclusterUsersGroupDns := tmpRespItemOfSecurityProfileclusterUsersGroupDns
					tmpRespOfSecurityProfileclusterUsersGroupDns = append(tmpRespOfSecurityProfileclusterUsersGroupDns, tmpRespValueOfSecurityProfileclusterUsersGroupDns)
				}
				tmpRespOfSecurityProfile["cluster_users_group_dns"] = tmpRespOfSecurityProfileclusterUsersGroupDns
			}
			d.Set("security_profile", tmpRespOfSecurityProfile)
		}
		if response.Properties.ComputeProfile != nil {
			if response.Properties.ComputeProfile.Roles != nil && len(*response.Properties.ComputeProfile.Roles) > 0 {
				tmpRespOfRoles := make([]interface{}, 0)
				for _, tmpRespItemOfRoles := range *response.Properties.ComputeProfile.Roles {
					tmpRespValueOfRoles := make(map[string]interface{})
					if tmpRespItemOfRoles.Name != nil {
						tmpRespValueOfRoles["name"] = *tmpRespItemOfRoles.Name
					}
					if tmpRespItemOfRoles.MinInstanceCount != nil {
						tmpRespValueOfRoles["min_instance_count"] = *tmpRespItemOfRoles.MinInstanceCount
					}
					if tmpRespItemOfRoles.TargetInstanceCount != nil {
						tmpRespValueOfRoles["target_instance_count"] = *tmpRespItemOfRoles.TargetInstanceCount
					}
					if tmpRespItemOfRoles.HardwareProfile != nil {
						if tmpRespItemOfRoles.HardwareProfile.VMSize != nil {
							tmpRespValueOfRoles["vm_size"] = *tmpRespItemOfRoles.HardwareProfile.VMSize
						}
					}
					if tmpRespItemOfRoles.OsProfile != nil {
						if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile != nil {
							tmpRespOfRoleslinuxOsProfile := make(map[string]interface{})
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username != nil {
								tmpRespOfRoleslinuxOsProfile["username"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password != nil {
								tmpRespOfRoleslinuxOsProfile["password"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile != nil {
								if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys != nil && len(*tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys) > 0 {
									tmpRespOfRoleslinuxOsProfilesshKeys := make([]interface{}, 0)
									for _, tmpRespItemOfRoleslinuxOsProfilesshKeys := range *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys {
										tmpRespValueOfRoleslinuxOsProfilesshKeys := make(map[string]interface{})
										if tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData != nil {
											tmpRespValueOfRoleslinuxOsProfilesshKeys["key_data"] = *tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData
										}
										tmpRespOfRoleslinuxOsProfilesshKeys = append(tmpRespOfRoleslinuxOsProfilesshKeys, tmpRespValueOfRoleslinuxOsProfilesshKeys)
									}
									tmpRespOfRoleslinuxOsProfile["ssh_keys"] = tmpRespOfRoleslinuxOsProfilesshKeys
								}
							}
							tmpRespValueOfRoles["linux_os_profile"] = tmpRespOfRoleslinuxOsProfile
						}
					}
					if tmpRespItemOfRoles.VirtualNetworkProfile != nil {
						tmpRespOfRolesvnetProfile := make(map[string]interface{})
						if tmpRespItemOfRoles.VirtualNetworkProfile.ID != nil {
							tmpRespOfRolesvnetProfile["id"] = *tmpRespItemOfRoles.VirtualNetworkProfile.ID
						}
						if tmpRespItemOfRoles.VirtualNetworkProfile.Subnet != nil {
							tmpRespOfRolesvnetProfile["subnet"] = *tmpRespItemOfRoles.VirtualNetworkProfile.Subnet
						}
						tmpRespValueOfRoles["vnet_profile"] = tmpRespOfRolesvnetProfile
					}
					if tmpRespItemOfRoles.DataDisksGroups != nil && len(*tmpRespItemOfRoles.DataDisksGroups) > 0 {
						tmpRespOfRolesdataDisksGroups := make([]interface{}, 0)
						for _, tmpRespItemOfRolesdataDisksGroups := range *tmpRespItemOfRoles.DataDisksGroups {
							tmpRespValueOfRolesdataDisksGroups := make(map[string]interface{})
							if tmpRespItemOfRolesdataDisksGroups.DisksPerNode != nil {
								tmpRespValueOfRolesdataDisksGroups["disks_per_node"] = *tmpRespItemOfRolesdataDisksGroups.DisksPerNode
							}
							if tmpRespItemOfRolesdataDisksGroups.StorageAccountType != nil {
								tmpRespValueOfRolesdataDisksGroups["storage_account_type"] = *tmpRespItemOfRolesdataDisksGroups.StorageAccountType
							}
							if tmpRespItemOfRolesdataDisksGroups.DiskSizeGB != nil {
								tmpRespValueOfRolesdataDisksGroups["disk_size_gb"] = *tmpRespItemOfRolesdataDisksGroups.DiskSizeGB
							}
							tmpRespOfRolesdataDisksGroups = append(tmpRespOfRolesdataDisksGroups, tmpRespValueOfRolesdataDisksGroups)
						}
						tmpRespValueOfRoles["data_disks_groups"] = tmpRespOfRolesdataDisksGroups
					}
					if tmpRespItemOfRoles.ScriptActions != nil && len(*tmpRespItemOfRoles.ScriptActions) > 0 {
						tmpRespOfRolesscriptActions := make([]interface{}, 0)
						for _, tmpRespItemOfRolesscriptActions := range *tmpRespItemOfRoles.ScriptActions {
							tmpRespValueOfRolesscriptActions := make(map[string]interface{})
							tmpRespValueOfRolesscriptActions["name"] = *tmpRespItemOfRolesscriptActions.Name
							tmpRespValueOfRolesscriptActions["uri"] = *tmpRespItemOfRolesscriptActions.URI
							tmpRespValueOfRolesscriptActions["parameters"] = *tmpRespItemOfRolesscriptActions.Parameters
							tmpRespOfRolesscriptActions = append(tmpRespOfRolesscriptActions, tmpRespValueOfRolesscriptActions)
						}
						tmpRespValueOfRoles["script_actions"] = tmpRespOfRolesscriptActions
					}
					tmpRespOfRoles = append(tmpRespOfRoles, tmpRespValueOfRoles)
				}
				d.Set("roles", tmpRespOfRoles)
			}
		}
		d.Set("provisioning_state", response.Properties.ProvisioningState)
		if response.Properties.CreatedDate != nil {
			d.Set("created_date", *response.Properties.CreatedDate)
		}
		if response.Properties.ClusterState != nil {
			d.Set("cluster_state", *response.Properties.ClusterState)
		}
		if response.Properties.QuotaInfo != nil {
			if response.Properties.QuotaInfo.CoresUsed != nil {
				d.Set("cores_used", *response.Properties.QuotaInfo.CoresUsed)
			}
		}
		if response.Properties.Errors != nil && len(*response.Properties.Errors) > 0 {
			tmpRespOfErrors := make([]interface{}, 0)
			for _, tmpRespItemOfErrors := range *response.Properties.Errors {
				tmpRespValueOfErrors := make(map[string]interface{})
				if tmpRespItemOfErrors.Code != nil {
					tmpRespValueOfErrors["code"] = *tmpRespItemOfErrors.Code
				}
				if tmpRespItemOfErrors.Message != nil {
					tmpRespValueOfErrors["message"] = *tmpRespItemOfErrors.Message
				}
				tmpRespOfErrors = append(tmpRespOfErrors, tmpRespValueOfErrors)
			}
			d.Set("errors", tmpRespOfErrors)
		}
		if response.Properties.ConnectivityEndpoints != nil && len(*response.Properties.ConnectivityEndpoints) > 0 {
			tmpRespOfConnectivityEndpoints := make([]interface{}, 0)
			for _, tmpRespItemOfConnectivityEndpoints := range *response.Properties.ConnectivityEndpoints {
				tmpRespValueOfConnectivityEndpoints := make(map[string]interface{})
				if tmpRespItemOfConnectivityEndpoints.Name != nil {
					tmpRespValueOfConnectivityEndpoints["name"] = *tmpRespItemOfConnectivityEndpoints.Name
				}
				if tmpRespItemOfConnectivityEndpoints.Protocol != nil {
					tmpRespValueOfConnectivityEndpoints["protocol"] = *tmpRespItemOfConnectivityEndpoints.Protocol
				}
				if tmpRespItemOfConnectivityEndpoints.Location != nil {
					tmpRespValueOfConnectivityEndpoints["location"] = *tmpRespItemOfConnectivityEndpoints.Location
				}
				if tmpRespItemOfConnectivityEndpoints.Port != nil {
					tmpRespValueOfConnectivityEndpoints["port"] = *tmpRespItemOfConnectivityEndpoints.Port
				}
				tmpRespOfConnectivityEndpoints = append(tmpRespOfConnectivityEndpoints, tmpRespValueOfConnectivityEndpoints)
			}
			d.Set("connectivity_endpoints", tmpRespOfConnectivityEndpoints)
		}
	}

	return nil
}

func resourceArmHDInsightClustersRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	resourceGroupName := d.Get("resource_group_name").(string)
	clusterName := d.Get("name").(string)

	response, err := client.Get(ctx, resourceGroupName, clusterName)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters read error: %+v", err)
	}

	if response.Name != nil {
		d.Set("name", *response.Name)
	}
	if response.Location != nil {
		d.Set("location", *response.Location)
	}
	flattenAndSetTags(d, response.Tags)
	if response.Properties != nil {
		if response.Properties.ClusterVersion != nil {
			d.Set("cluster_version", *response.Properties.ClusterVersion)
		}
		d.Set("os_type", response.Properties.OsType)
		d.Set("tier", response.Properties.Tier)
		if response.Properties.ClusterDefinition.Blueprint != nil {
			d.Set("blueprint", *response.Properties.ClusterDefinition.Blueprint)
		}
		if response.Properties.ClusterDefinition.Kind != nil {
			d.Set("kind", *response.Properties.ClusterDefinition.Kind)
		}
		if response.Properties.ClusterDefinition.ComponentVersion != nil {
			tmpRespOfComponentVersion := make(map[string]interface{})
			for tmpRespKeyOfComponentVersion, tmpRespItemOfComponentVersion := range *response.Properties.ClusterDefinition.ComponentVersion {
				tmpRespValueOfComponentVersion := *tmpRespItemOfComponentVersion
				tmpRespOfComponentVersion[tmpRespKeyOfComponentVersion] = tmpRespValueOfComponentVersion
			}
			d.Set("component_version", tmpRespOfComponentVersion)
		}
		if response.Properties.ClusterDefinition.Configurations != nil {
			tmpRespOfConfigurations := make(map[string]interface{})
			for tmpRespKeyOfConfigurations, tmpRespItemOfConfigurations := range *response.Properties.ClusterDefinition.Configurations {
				tmpRespOfConfigurations1 := make(map[string]interface{})
				for tmpRespKeyOfConfigurations1, tmpRespItemOfConfigurations1 := range *tmpRespItemOfConfigurations.(*map[string]*string) {
					tmpRespValueOfConfigurations1 := *tmpRespItemOfConfigurations1
					tmpRespOfConfigurations1[tmpRespKeyOfConfigurations1] = tmpRespValueOfConfigurations1
				}
				tmpRespOfConfigurations[tmpRespKeyOfConfigurations] = tmpRespOfConfigurations1
			}
			d.Set("configurations", tmpRespOfConfigurations)
		}
		if response.Properties.SecurityProfile != nil {
			tmpRespOfSecurityProfile := make(map[string]interface{})
			tmpRespOfSecurityProfile["directory_type"] = response.Properties.SecurityProfile.DirectoryType
			if response.Properties.SecurityProfile.Domain != nil {
				tmpRespOfSecurityProfile["domain"] = *response.Properties.SecurityProfile.Domain
			}
			if response.Properties.SecurityProfile.OrganizationalUnitDN != nil {
				tmpRespOfSecurityProfile["organizational_unit_dn"] = *response.Properties.SecurityProfile.OrganizationalUnitDN
			}
			if response.Properties.SecurityProfile.LdapsUrls != nil && len(*response.Properties.SecurityProfile.LdapsUrls) > 0 {
				tmpRespOfSecurityProfileldapsUrls := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileldapsUrls := range *response.Properties.SecurityProfile.LdapsUrls {
					tmpRespValueOfSecurityProfileldapsUrls := tmpRespItemOfSecurityProfileldapsUrls
					tmpRespOfSecurityProfileldapsUrls = append(tmpRespOfSecurityProfileldapsUrls, tmpRespValueOfSecurityProfileldapsUrls)
				}
				tmpRespOfSecurityProfile["ldaps_urls"] = tmpRespOfSecurityProfileldapsUrls
			}
			if response.Properties.SecurityProfile.DomainUsername != nil {
				tmpRespOfSecurityProfile["domain_username"] = *response.Properties.SecurityProfile.DomainUsername
			}
			if response.Properties.SecurityProfile.DomainUserPassword != nil {
				tmpRespOfSecurityProfile["domain_user_password"] = *response.Properties.SecurityProfile.DomainUserPassword
			}
			if response.Properties.SecurityProfile.ClusterUsersGroupDNS != nil && len(*response.Properties.SecurityProfile.ClusterUsersGroupDNS) > 0 {
				tmpRespOfSecurityProfileclusterUsersGroupDns := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileclusterUsersGroupDns := range *response.Properties.SecurityProfile.ClusterUsersGroupDNS {
					tmpRespValueOfSecurityProfileclusterUsersGroupDns := tmpRespItemOfSecurityProfileclusterUsersGroupDns
					tmpRespOfSecurityProfileclusterUsersGroupDns = append(tmpRespOfSecurityProfileclusterUsersGroupDns, tmpRespValueOfSecurityProfileclusterUsersGroupDns)
				}
				tmpRespOfSecurityProfile["cluster_users_group_dns"] = tmpRespOfSecurityProfileclusterUsersGroupDns
			}
			d.Set("security_profile", tmpRespOfSecurityProfile)
		}
		if response.Properties.ComputeProfile != nil {
			if response.Properties.ComputeProfile.Roles != nil && len(*response.Properties.ComputeProfile.Roles) > 0 {
				tmpRespOfRoles := make([]interface{}, 0)
				for _, tmpRespItemOfRoles := range *response.Properties.ComputeProfile.Roles {
					tmpRespValueOfRoles := make(map[string]interface{})
					if tmpRespItemOfRoles.Name != nil {
						tmpRespValueOfRoles["name"] = *tmpRespItemOfRoles.Name
					}
					if tmpRespItemOfRoles.MinInstanceCount != nil {
						tmpRespValueOfRoles["min_instance_count"] = *tmpRespItemOfRoles.MinInstanceCount
					}
					if tmpRespItemOfRoles.TargetInstanceCount != nil {
						tmpRespValueOfRoles["target_instance_count"] = *tmpRespItemOfRoles.TargetInstanceCount
					}
					if tmpRespItemOfRoles.HardwareProfile != nil {
						if tmpRespItemOfRoles.HardwareProfile.VMSize != nil {
							tmpRespValueOfRoles["vm_size"] = *tmpRespItemOfRoles.HardwareProfile.VMSize
						}
					}
					if tmpRespItemOfRoles.OsProfile != nil {
						if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile != nil {
							tmpRespOfRoleslinuxOsProfile := make(map[string]interface{})
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username != nil {
								tmpRespOfRoleslinuxOsProfile["username"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password != nil {
								tmpRespOfRoleslinuxOsProfile["password"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile != nil {
								if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys != nil && len(*tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys) > 0 {
									tmpRespOfRoleslinuxOsProfilesshKeys := make([]interface{}, 0)
									for _, tmpRespItemOfRoleslinuxOsProfilesshKeys := range *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys {
										tmpRespValueOfRoleslinuxOsProfilesshKeys := make(map[string]interface{})
										if tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData != nil {
											tmpRespValueOfRoleslinuxOsProfilesshKeys["key_data"] = *tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData
										}
										tmpRespOfRoleslinuxOsProfilesshKeys = append(tmpRespOfRoleslinuxOsProfilesshKeys, tmpRespValueOfRoleslinuxOsProfilesshKeys)
									}
									tmpRespOfRoleslinuxOsProfile["ssh_keys"] = tmpRespOfRoleslinuxOsProfilesshKeys
								}
							}
							tmpRespValueOfRoles["linux_os_profile"] = tmpRespOfRoleslinuxOsProfile
						}
					}
					if tmpRespItemOfRoles.VirtualNetworkProfile != nil {
						tmpRespOfRolesvnetProfile := make(map[string]interface{})
						if tmpRespItemOfRoles.VirtualNetworkProfile.ID != nil {
							tmpRespOfRolesvnetProfile["id"] = *tmpRespItemOfRoles.VirtualNetworkProfile.ID
						}
						if tmpRespItemOfRoles.VirtualNetworkProfile.Subnet != nil {
							tmpRespOfRolesvnetProfile["subnet"] = *tmpRespItemOfRoles.VirtualNetworkProfile.Subnet
						}
						tmpRespValueOfRoles["vnet_profile"] = tmpRespOfRolesvnetProfile
					}
					if tmpRespItemOfRoles.DataDisksGroups != nil && len(*tmpRespItemOfRoles.DataDisksGroups) > 0 {
						tmpRespOfRolesdataDisksGroups := make([]interface{}, 0)
						for _, tmpRespItemOfRolesdataDisksGroups := range *tmpRespItemOfRoles.DataDisksGroups {
							tmpRespValueOfRolesdataDisksGroups := make(map[string]interface{})
							if tmpRespItemOfRolesdataDisksGroups.DisksPerNode != nil {
								tmpRespValueOfRolesdataDisksGroups["disks_per_node"] = *tmpRespItemOfRolesdataDisksGroups.DisksPerNode
							}
							if tmpRespItemOfRolesdataDisksGroups.StorageAccountType != nil {
								tmpRespValueOfRolesdataDisksGroups["storage_account_type"] = *tmpRespItemOfRolesdataDisksGroups.StorageAccountType
							}
							if tmpRespItemOfRolesdataDisksGroups.DiskSizeGB != nil {
								tmpRespValueOfRolesdataDisksGroups["disk_size_gb"] = *tmpRespItemOfRolesdataDisksGroups.DiskSizeGB
							}
							tmpRespOfRolesdataDisksGroups = append(tmpRespOfRolesdataDisksGroups, tmpRespValueOfRolesdataDisksGroups)
						}
						tmpRespValueOfRoles["data_disks_groups"] = tmpRespOfRolesdataDisksGroups
					}
					if tmpRespItemOfRoles.ScriptActions != nil && len(*tmpRespItemOfRoles.ScriptActions) > 0 {
						tmpRespOfRolesscriptActions := make([]interface{}, 0)
						for _, tmpRespItemOfRolesscriptActions := range *tmpRespItemOfRoles.ScriptActions {
							tmpRespValueOfRolesscriptActions := make(map[string]interface{})
							tmpRespValueOfRolesscriptActions["name"] = *tmpRespItemOfRolesscriptActions.Name
							tmpRespValueOfRolesscriptActions["uri"] = *tmpRespItemOfRolesscriptActions.URI
							tmpRespValueOfRolesscriptActions["parameters"] = *tmpRespItemOfRolesscriptActions.Parameters
							tmpRespOfRolesscriptActions = append(tmpRespOfRolesscriptActions, tmpRespValueOfRolesscriptActions)
						}
						tmpRespValueOfRoles["script_actions"] = tmpRespOfRolesscriptActions
					}
					tmpRespOfRoles = append(tmpRespOfRoles, tmpRespValueOfRoles)
				}
				d.Set("roles", tmpRespOfRoles)
			}
		}
		d.Set("provisioning_state", response.Properties.ProvisioningState)
		if response.Properties.CreatedDate != nil {
			d.Set("created_date", *response.Properties.CreatedDate)
		}
		if response.Properties.ClusterState != nil {
			d.Set("cluster_state", *response.Properties.ClusterState)
		}
		if response.Properties.QuotaInfo != nil {
			if response.Properties.QuotaInfo.CoresUsed != nil {
				d.Set("cores_used", *response.Properties.QuotaInfo.CoresUsed)
			}
		}
		if response.Properties.Errors != nil && len(*response.Properties.Errors) > 0 {
			tmpRespOfErrors := make([]interface{}, 0)
			for _, tmpRespItemOfErrors := range *response.Properties.Errors {
				tmpRespValueOfErrors := make(map[string]interface{})
				if tmpRespItemOfErrors.Code != nil {
					tmpRespValueOfErrors["code"] = *tmpRespItemOfErrors.Code
				}
				if tmpRespItemOfErrors.Message != nil {
					tmpRespValueOfErrors["message"] = *tmpRespItemOfErrors.Message
				}
				tmpRespOfErrors = append(tmpRespOfErrors, tmpRespValueOfErrors)
			}
			d.Set("errors", tmpRespOfErrors)
		}
		if response.Properties.ConnectivityEndpoints != nil && len(*response.Properties.ConnectivityEndpoints) > 0 {
			tmpRespOfConnectivityEndpoints := make([]interface{}, 0)
			for _, tmpRespItemOfConnectivityEndpoints := range *response.Properties.ConnectivityEndpoints {
				tmpRespValueOfConnectivityEndpoints := make(map[string]interface{})
				if tmpRespItemOfConnectivityEndpoints.Name != nil {
					tmpRespValueOfConnectivityEndpoints["name"] = *tmpRespItemOfConnectivityEndpoints.Name
				}
				if tmpRespItemOfConnectivityEndpoints.Protocol != nil {
					tmpRespValueOfConnectivityEndpoints["protocol"] = *tmpRespItemOfConnectivityEndpoints.Protocol
				}
				if tmpRespItemOfConnectivityEndpoints.Location != nil {
					tmpRespValueOfConnectivityEndpoints["location"] = *tmpRespItemOfConnectivityEndpoints.Location
				}
				if tmpRespItemOfConnectivityEndpoints.Port != nil {
					tmpRespValueOfConnectivityEndpoints["port"] = *tmpRespItemOfConnectivityEndpoints.Port
				}
				tmpRespOfConnectivityEndpoints = append(tmpRespOfConnectivityEndpoints, tmpRespValueOfConnectivityEndpoints)
			}
			d.Set("connectivity_endpoints", tmpRespOfConnectivityEndpoints)
		}
	}

	return nil
}

func resourceArmHDInsightClustersUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	resourceGroupName := d.Get("resource_group_name").(string)
	clusterName := d.Get("name").(string)
	parameters := hdinsight.ClusterPatchParameters{}
	tags := d.Get("tags").(map[string]interface{})
	tmpParamOfTags := expandTags(tags)
	parameters.Tags = tmpParamOfTags

	response, err := client.Update(ctx, resourceGroupName, clusterName, parameters)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters update error: %+v", err)
	}

	if response.Name != nil {
		d.Set("name", *response.Name)
	}
	if response.Location != nil {
		d.Set("location", *response.Location)
	}
	flattenAndSetTags(d, response.Tags)
	if response.Properties != nil {
		if response.Properties.ClusterVersion != nil {
			d.Set("cluster_version", *response.Properties.ClusterVersion)
		}
		d.Set("os_type", response.Properties.OsType)
		d.Set("tier", response.Properties.Tier)
		if response.Properties.ClusterDefinition.Blueprint != nil {
			d.Set("blueprint", *response.Properties.ClusterDefinition.Blueprint)
		}
		if response.Properties.ClusterDefinition.Kind != nil {
			d.Set("kind", *response.Properties.ClusterDefinition.Kind)
		}
		if response.Properties.ClusterDefinition.ComponentVersion != nil {
			tmpRespOfComponentVersion := make(map[string]interface{})
			for tmpRespKeyOfComponentVersion, tmpRespItemOfComponentVersion := range *response.Properties.ClusterDefinition.ComponentVersion {
				tmpRespValueOfComponentVersion := *tmpRespItemOfComponentVersion
				tmpRespOfComponentVersion[tmpRespKeyOfComponentVersion] = tmpRespValueOfComponentVersion
			}
			d.Set("component_version", tmpRespOfComponentVersion)
		}
		if response.Properties.ClusterDefinition.Configurations != nil {
			tmpRespOfConfigurations := make(map[string]interface{})
			for tmpRespKeyOfConfigurations, tmpRespItemOfConfigurations := range *response.Properties.ClusterDefinition.Configurations {
				tmpRespOfConfigurations1 := make(map[string]interface{})
				for tmpRespKeyOfConfigurations1, tmpRespItemOfConfigurations1 := range *tmpRespItemOfConfigurations.(*map[string]*string) {
					tmpRespValueOfConfigurations1 := *tmpRespItemOfConfigurations1
					tmpRespOfConfigurations1[tmpRespKeyOfConfigurations1] = tmpRespValueOfConfigurations1
				}
				tmpRespOfConfigurations[tmpRespKeyOfConfigurations] = tmpRespOfConfigurations1
			}
			d.Set("configurations", tmpRespOfConfigurations)
		}
		if response.Properties.SecurityProfile != nil {
			tmpRespOfSecurityProfile := make(map[string]interface{})
			tmpRespOfSecurityProfile["directory_type"] = response.Properties.SecurityProfile.DirectoryType
			if response.Properties.SecurityProfile.Domain != nil {
				tmpRespOfSecurityProfile["domain"] = *response.Properties.SecurityProfile.Domain
			}
			if response.Properties.SecurityProfile.OrganizationalUnitDN != nil {
				tmpRespOfSecurityProfile["organizational_unit_dn"] = *response.Properties.SecurityProfile.OrganizationalUnitDN
			}
			if response.Properties.SecurityProfile.LdapsUrls != nil && len(*response.Properties.SecurityProfile.LdapsUrls) > 0 {
				tmpRespOfSecurityProfileldapsUrls := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileldapsUrls := range *response.Properties.SecurityProfile.LdapsUrls {
					tmpRespValueOfSecurityProfileldapsUrls := tmpRespItemOfSecurityProfileldapsUrls
					tmpRespOfSecurityProfileldapsUrls = append(tmpRespOfSecurityProfileldapsUrls, tmpRespValueOfSecurityProfileldapsUrls)
				}
				tmpRespOfSecurityProfile["ldaps_urls"] = tmpRespOfSecurityProfileldapsUrls
			}
			if response.Properties.SecurityProfile.DomainUsername != nil {
				tmpRespOfSecurityProfile["domain_username"] = *response.Properties.SecurityProfile.DomainUsername
			}
			if response.Properties.SecurityProfile.DomainUserPassword != nil {
				tmpRespOfSecurityProfile["domain_user_password"] = *response.Properties.SecurityProfile.DomainUserPassword
			}
			if response.Properties.SecurityProfile.ClusterUsersGroupDNS != nil && len(*response.Properties.SecurityProfile.ClusterUsersGroupDNS) > 0 {
				tmpRespOfSecurityProfileclusterUsersGroupDns := make([]interface{}, 0)
				for _, tmpRespItemOfSecurityProfileclusterUsersGroupDns := range *response.Properties.SecurityProfile.ClusterUsersGroupDNS {
					tmpRespValueOfSecurityProfileclusterUsersGroupDns := tmpRespItemOfSecurityProfileclusterUsersGroupDns
					tmpRespOfSecurityProfileclusterUsersGroupDns = append(tmpRespOfSecurityProfileclusterUsersGroupDns, tmpRespValueOfSecurityProfileclusterUsersGroupDns)
				}
				tmpRespOfSecurityProfile["cluster_users_group_dns"] = tmpRespOfSecurityProfileclusterUsersGroupDns
			}
			d.Set("security_profile", tmpRespOfSecurityProfile)
		}
		if response.Properties.ComputeProfile != nil {
			if response.Properties.ComputeProfile.Roles != nil && len(*response.Properties.ComputeProfile.Roles) > 0 {
				tmpRespOfRoles := make([]interface{}, 0)
				for _, tmpRespItemOfRoles := range *response.Properties.ComputeProfile.Roles {
					tmpRespValueOfRoles := make(map[string]interface{})
					if tmpRespItemOfRoles.Name != nil {
						tmpRespValueOfRoles["name"] = *tmpRespItemOfRoles.Name
					}
					if tmpRespItemOfRoles.MinInstanceCount != nil {
						tmpRespValueOfRoles["min_instance_count"] = *tmpRespItemOfRoles.MinInstanceCount
					}
					if tmpRespItemOfRoles.TargetInstanceCount != nil {
						tmpRespValueOfRoles["target_instance_count"] = *tmpRespItemOfRoles.TargetInstanceCount
					}
					if tmpRespItemOfRoles.HardwareProfile != nil {
						if tmpRespItemOfRoles.HardwareProfile.VMSize != nil {
							tmpRespValueOfRoles["vm_size"] = *tmpRespItemOfRoles.HardwareProfile.VMSize
						}
					}
					if tmpRespItemOfRoles.OsProfile != nil {
						if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile != nil {
							tmpRespOfRoleslinuxOsProfile := make(map[string]interface{})
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username != nil {
								tmpRespOfRoleslinuxOsProfile["username"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Username
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password != nil {
								tmpRespOfRoleslinuxOsProfile["password"] = *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.Password
							}
							if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile != nil {
								if tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys != nil && len(*tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys) > 0 {
									tmpRespOfRoleslinuxOsProfilesshKeys := make([]interface{}, 0)
									for _, tmpRespItemOfRoleslinuxOsProfilesshKeys := range *tmpRespItemOfRoles.OsProfile.LinuxOperatingSystemProfile.SSHProfile.PublicKeys {
										tmpRespValueOfRoleslinuxOsProfilesshKeys := make(map[string]interface{})
										if tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData != nil {
											tmpRespValueOfRoleslinuxOsProfilesshKeys["key_data"] = *tmpRespItemOfRoleslinuxOsProfilesshKeys.CertificateData
										}
										tmpRespOfRoleslinuxOsProfilesshKeys = append(tmpRespOfRoleslinuxOsProfilesshKeys, tmpRespValueOfRoleslinuxOsProfilesshKeys)
									}
									tmpRespOfRoleslinuxOsProfile["ssh_keys"] = tmpRespOfRoleslinuxOsProfilesshKeys
								}
							}
							tmpRespValueOfRoles["linux_os_profile"] = tmpRespOfRoleslinuxOsProfile
						}
					}
					if tmpRespItemOfRoles.VirtualNetworkProfile != nil {
						tmpRespOfRolesvnetProfile := make(map[string]interface{})
						if tmpRespItemOfRoles.VirtualNetworkProfile.ID != nil {
							tmpRespOfRolesvnetProfile["id"] = *tmpRespItemOfRoles.VirtualNetworkProfile.ID
						}
						if tmpRespItemOfRoles.VirtualNetworkProfile.Subnet != nil {
							tmpRespOfRolesvnetProfile["subnet"] = *tmpRespItemOfRoles.VirtualNetworkProfile.Subnet
						}
						tmpRespValueOfRoles["vnet_profile"] = tmpRespOfRolesvnetProfile
					}
					if tmpRespItemOfRoles.DataDisksGroups != nil && len(*tmpRespItemOfRoles.DataDisksGroups) > 0 {
						tmpRespOfRolesdataDisksGroups := make([]interface{}, 0)
						for _, tmpRespItemOfRolesdataDisksGroups := range *tmpRespItemOfRoles.DataDisksGroups {
							tmpRespValueOfRolesdataDisksGroups := make(map[string]interface{})
							if tmpRespItemOfRolesdataDisksGroups.DisksPerNode != nil {
								tmpRespValueOfRolesdataDisksGroups["disks_per_node"] = *tmpRespItemOfRolesdataDisksGroups.DisksPerNode
							}
							if tmpRespItemOfRolesdataDisksGroups.StorageAccountType != nil {
								tmpRespValueOfRolesdataDisksGroups["storage_account_type"] = *tmpRespItemOfRolesdataDisksGroups.StorageAccountType
							}
							if tmpRespItemOfRolesdataDisksGroups.DiskSizeGB != nil {
								tmpRespValueOfRolesdataDisksGroups["disk_size_gb"] = *tmpRespItemOfRolesdataDisksGroups.DiskSizeGB
							}
							tmpRespOfRolesdataDisksGroups = append(tmpRespOfRolesdataDisksGroups, tmpRespValueOfRolesdataDisksGroups)
						}
						tmpRespValueOfRoles["data_disks_groups"] = tmpRespOfRolesdataDisksGroups
					}
					if tmpRespItemOfRoles.ScriptActions != nil && len(*tmpRespItemOfRoles.ScriptActions) > 0 {
						tmpRespOfRolesscriptActions := make([]interface{}, 0)
						for _, tmpRespItemOfRolesscriptActions := range *tmpRespItemOfRoles.ScriptActions {
							tmpRespValueOfRolesscriptActions := make(map[string]interface{})
							tmpRespValueOfRolesscriptActions["name"] = *tmpRespItemOfRolesscriptActions.Name
							tmpRespValueOfRolesscriptActions["uri"] = *tmpRespItemOfRolesscriptActions.URI
							tmpRespValueOfRolesscriptActions["parameters"] = *tmpRespItemOfRolesscriptActions.Parameters
							tmpRespOfRolesscriptActions = append(tmpRespOfRolesscriptActions, tmpRespValueOfRolesscriptActions)
						}
						tmpRespValueOfRoles["script_actions"] = tmpRespOfRolesscriptActions
					}
					tmpRespOfRoles = append(tmpRespOfRoles, tmpRespValueOfRoles)
				}
				d.Set("roles", tmpRespOfRoles)
			}
		}
		d.Set("provisioning_state", response.Properties.ProvisioningState)
		if response.Properties.CreatedDate != nil {
			d.Set("created_date", *response.Properties.CreatedDate)
		}
		if response.Properties.ClusterState != nil {
			d.Set("cluster_state", *response.Properties.ClusterState)
		}
		if response.Properties.QuotaInfo != nil {
			if response.Properties.QuotaInfo.CoresUsed != nil {
				d.Set("cores_used", *response.Properties.QuotaInfo.CoresUsed)
			}
		}
		if response.Properties.Errors != nil && len(*response.Properties.Errors) > 0 {
			tmpRespOfErrors := make([]interface{}, 0)
			for _, tmpRespItemOfErrors := range *response.Properties.Errors {
				tmpRespValueOfErrors := make(map[string]interface{})
				if tmpRespItemOfErrors.Code != nil {
					tmpRespValueOfErrors["code"] = *tmpRespItemOfErrors.Code
				}
				if tmpRespItemOfErrors.Message != nil {
					tmpRespValueOfErrors["message"] = *tmpRespItemOfErrors.Message
				}
				tmpRespOfErrors = append(tmpRespOfErrors, tmpRespValueOfErrors)
			}
			d.Set("errors", tmpRespOfErrors)
		}
		if response.Properties.ConnectivityEndpoints != nil && len(*response.Properties.ConnectivityEndpoints) > 0 {
			tmpRespOfConnectivityEndpoints := make([]interface{}, 0)
			for _, tmpRespItemOfConnectivityEndpoints := range *response.Properties.ConnectivityEndpoints {
				tmpRespValueOfConnectivityEndpoints := make(map[string]interface{})
				if tmpRespItemOfConnectivityEndpoints.Name != nil {
					tmpRespValueOfConnectivityEndpoints["name"] = *tmpRespItemOfConnectivityEndpoints.Name
				}
				if tmpRespItemOfConnectivityEndpoints.Protocol != nil {
					tmpRespValueOfConnectivityEndpoints["protocol"] = *tmpRespItemOfConnectivityEndpoints.Protocol
				}
				if tmpRespItemOfConnectivityEndpoints.Location != nil {
					tmpRespValueOfConnectivityEndpoints["location"] = *tmpRespItemOfConnectivityEndpoints.Location
				}
				if tmpRespItemOfConnectivityEndpoints.Port != nil {
					tmpRespValueOfConnectivityEndpoints["port"] = *tmpRespItemOfConnectivityEndpoints.Port
				}
				tmpRespOfConnectivityEndpoints = append(tmpRespOfConnectivityEndpoints, tmpRespValueOfConnectivityEndpoints)
			}
			d.Set("connectivity_endpoints", tmpRespOfConnectivityEndpoints)
		}
	}

	return nil
}

func resourceArmHDInsightClustersDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClustersClient
	ctx := meta.(*ArmClient).StopContext

	resourceGroupName := d.Get("resource_group_name").(string)
	clusterName := d.Get("name").(string)

	future, err := client.Delete(ctx, resourceGroupName, clusterName)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters deletion error: %+v", err)
	}
	err = future.WaitForCompletion(ctx, client.Client)
	if err != nil {
		return fmt.Errorf("HD Insight Clusters deletion future wait for completion error: %+v", err)
	}

	return nil
}
